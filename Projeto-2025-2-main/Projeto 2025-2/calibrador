import cv2
import numpy as np
import tkinter as tk
from tkinter import filedialog
import sys
from pathlib import Path # Importa o Path

# --- 1. Copiamos a sua função 'safe_imread' ---
# (Baseado no seu script Reconhecedor de imagem.py)
def safe_imread(path: str):
    p = Path(path)
    if not p.exists():
        print(f"[ERRO] Caminho não existe: {p}")
        return None
    try:
        # Tenta o método robusto primeiro
        data = np.fromfile(str(p), dtype=np.uint8)
        img = cv2.imdecode(data, cv2.IMREAD_UNCHANGED) #
    except Exception as e:
        print(f"[ERRO] imdecode falhou: {e}, tentando imread padrão...")
        # Tenta o imread padrão como fallback
        img = cv2.imread(str(p), cv2.IMREAD_UNCHANGED)

    if img is None:
        return None
        
    # BGRA->BGR (do seu script original)
    if img.ndim == 3 and img.shape[2] == 4:
        img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
    return img

# --- 2. Seletor de Arquivos (GUI) ---
def selecionar_imagem_gui():
    """
    Abre uma janela de diálogo para o usuário selecionar
    uma imagem para calibrar.
    """
    print("Abrindo explorador de arquivos...")
    try:
        root = tk.Tk()
        root.withdraw() 
        root.attributes("-topmost", True)
        path_str = filedialog.askopenfilename(
            parent=root,
            title="Selecione a imagem de exemplo para CALIBRAR",
            filetypes=[("Imagens", "*.png *.jpg *.jpeg *.tif *.webp")]
        )
        root.destroy()
    except Exception as e:
        print(f"Erro ao iniciar o seletor de arquivos (Tkinter): {e}")
        return None

    if not path_str:
        print("Nenhuma imagem selecionada. Encerrando.")
        return None
    
    return path_str

# --- 3. Função de Callback Vazia ---
def nada(x):
    pass

# --- 4. Função Principal de Calibração ---
def calibrar():
    img_path = selecionar_imagem_gui()
    if img_path is None:
        return

    # --- CORREÇÃO AQUI ---
    # img = cv2.imread(img_path) # <- Linha antiga com erro
    img = safe_imread(img_path) # <- Nova linha usando sua função
    # --- FIM DA CORREÇÃO ---

    if img is None: 
        print(f"Erro: Não foi possível carregar a imagem em: {img_path}")
        return

    # Redimensiona a imagem se ela for muito grande...
    h, w = img.shape[:2]
    max_dim = 800
    if h > max_dim or w > max_dim:
        escala = max_dim / max(h, w)
        img = cv2.resize(img, None, fx=escala, fy=escala, interpolation=cv2.INTER_AREA)

    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # --- Criação das Janelas ---
    cv2.namedWindow("Original")
    cv2.namedWindow("Mascara")
    cv2.namedWindow("Resultado (Overlay)")
    cv2.namedWindow("Controles")
    
    cv2.moveWindow("Original", 0, 0)
    cv2.moveWindow("Controles", 0, 500)
    cv2.moveWindow("Mascara", 650, 0)
    cv2.moveWindow("Resultado (Overlay)", 650, 500)

    # Valores Iniciais (baseados no seu processador_automatico.py)
    H_MIN_INIT = 0
    S_MIN_INIT = 20
    V_MIN_INIT = 20
    H_MAX_INIT = 40
    S_MAX_INIT = 255
    V_MAX_INIT = 255

    # --- Criação dos Sliders (Trackbars) ---
    cv2.createTrackbar("H Min", "Controles", H_MIN_INIT, 179, nada)
    cv2.createTrackbar("S Min", "Controles", S_MIN_INIT, 255, nada)
    cv2.createTrackbar("V Min", "Controles", V_MIN_INIT, 255, nada)
    cv2.createTrackbar("H Max", "Controles", H_MAX_INIT, 179, nada)
    cv2.createTrackbar("S Max", "Controles", S_MAX_INIT, 255, nada)
    cv2.createTrackbar("V Max", "Controles", V_MAX_INIT, 255, nada)

    print("\n" + "="*40)
    print("INICIANDO CALIBRAÇÃO INTERATIVA")
    print("1. Ajuste os sliders na janela 'Controles'.")
    print("2. Veja o resultado em 'Mascara' e 'Resultado'.")
    print("3. Pressione 'q' na janela da imagem para sair.")
    print("="*40)
    
    while True:
        h_min = cv2.getTrackbarPos("H Min", "Controles")
        s_min = cv2.getTrackbarPos("S Min", "Controles")
        v_min = cv2.getTrackbarPos("V Min", "Controles")
        h_max = cv2.getTrackbarPos("H Max", "Controles")
        s_max = cv2.getTrackbarPos("S Max", "Controles")
        v_max = cv2.getTrackbarPos("V Max", "Controles")

        lower = np.array([h_min, s_min, v_min])
        upper = np.array([h_max, s_max, v_max])

        mask = cv2.inRange(hsv, lower, upper)
        
        overlay_img = img.copy()
        overlay_img[mask > 0] = [0, 0, 255] # Vermelho (BGR)
        resultado = cv2.addWeighted(overlay_img, 0.7, img, 0.3, 0)

        cv2.imshow("Original", img)
        cv2.imshow("Mascara", mask)
        cv2.imshow("Resultado (Overlay)", resultado)

        key = cv2.waitKey(1) & 0xFF
        if key == ord('q'):
            break

    cv2.destroyAllWindows()
    
    print("\n" + "="*40)
    print("CALIBRAÇÃO CONCLUÍDA.")
    print("Copie estas linhas e cole no seu 'processador_automatico.py':\n")
    print(f"LOWER_HSV_FIXO = np.array([{h_min}, {s_min}, {v_min}], dtype=np.uint8)")
    print(f"UPPER_HSV_FIXO = np.array([{h_max}, {s_max}, {v_max}], dtype=np.uint8)")
    print("="*40)

# --- Executa a função principal ---
if __name__ == "__main__":
    calibrar()